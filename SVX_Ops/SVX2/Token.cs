using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace SVX2
{
    // Conveniently, the one class with an SVX_Ops dependency is one that we
    // shouldn't need to call from an SVX method.  But it would be much better
    // to fix the BCT omit attributes and make a single assembly to stop this
    // madness.

    public abstract class MessagePayloadSecretGenerator<TMessage> where TMessage : SVX_MSG
    {
        protected abstract PrincipalHandle Signer { get; }

        protected abstract string RawGenerate(TMessage message);
        protected abstract TMessage RawExtractUnverified(string secretValue);

        // On verification failure, this should throw an exception.
        protected abstract TMessage RawVerifyAndExtract(string secretValue);

        protected internal abstract PrincipalHandle[] GetReaders(object/*TMessage*/ message);

        public PayloadSecret<TMessage> Generate(TMessage message, Principal currentPrincipal)
        {
            if (currentPrincipal != Signer)
                throw new Exception("Misconfiguration: current principal is signing a message " +
                    "but is not the designated signer for this secret generator.");
            // XXX Would it be more consistent to make the message nondet instead?
            if (!message.active)
                throw new InvalidOperationException("Cannot sign a message without an active SymT");
            var readers = (PrincipalHandle[])GetReaders(message).Clone();
            if (!readers.Contains(currentPrincipal))
                throw new Exception("Misconfiguration: secret generated by a principal not on its reader list.");
            return new PayloadSecret<TMessage>
            {
                theParams = message,
                secretValue = RawGenerate(message),
                knownReaders = readers
            };
        }

        // To prevent a secret value from being leaked by passing it to a
        // PayloadSecretGenerator for the wrong secret format, which thinks the
        // secret part is a public part and extracts it, these methods are
        // restricted to be called only via a MessageStructure on import.  TBD
        // what to do if this doesn't end up meeting our needs.

        internal void ExtractUnverified(PayloadSecret<TMessage> secret)
        {
            secret.theParams = RawExtractUnverified(secret.secretValue);
            VProgram_API.Assert(secret.theParams != null);
        }

        internal void VerifyAndExtract(PayloadSecret<TMessage> secret)
        {
            try
            {
                secret.theParams = RawVerifyAndExtract(secret.secretValue);
            }
            catch { throw; }
            // This currently can't be called from SVX methods, so we don't
            // actually have to do the vProgram-specific stuff.
            //// Maybe non-nullness of the root message is as much as we can say in general?
            //VProgram_API.Assert(secret.theParams != null);
            //VProgram_API.Assert(secret.secretValue != null);
            //VProgram_API.AssumeValidSecret(secret.secretValue, GetReaders(secret.theParams));
            // Verification succeeded, so we should be able to activate the SymT.
            SVX_Ops.TransferNested(secret.theParams, Signer);
        }
    }
}
