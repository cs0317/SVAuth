using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace SVX2
{
    // Conveniently, the one class with an SVX_Ops dependency is one that we
    // shouldn't need to call from an SVX method.  But it would be much better
    // to fix the BCT omit attributes and make a single assembly to stop this
    // madness.

    public abstract class MessagePayloadSecretGenerator<TMessage> where TMessage : SVX_MSG
    {
        protected internal abstract PrincipalHandle Signer { get; }

        protected abstract string RawGenerate(TMessage message);
        protected abstract TMessage RawExtractUnverified(string secretValue);

        // On verification failure, this should throw an exception.
        protected abstract TMessage RawVerifyAndExtract(string secretValue);

        // Should return a new array each time.
        protected internal abstract PrincipalHandle[] GetReaders(object/*TMessage*/ message);

        [BCTOmitImplementation]
        string RawGenerateWrapper(TMessage message)
        {
            return RawGenerate(message);
        }

        public PayloadSecret<TMessage> Generate(TMessage message, Principal currentPrincipal)
        {
            var readers = GetReaders(message);
            // None of these checks are really the business of the vProgram, and
            // in particular, !message.active will be a contradiction.
            if (!VProgram_API.InVProgram)
            {
                if (currentPrincipal != Signer)
                    throw new Exception("Misconfiguration: current principal is signing a message " +
                        "but is not the designated signer for this secret generator.");
                // XXX Would it be more consistent to make the message nondet instead?
                if (!message.active)
                    throw new InvalidOperationException("Cannot sign a message without an active SymT");
                if (!readers.Contains(currentPrincipal))
                    throw new Exception("Misconfiguration: secret generated by a principal not on its reader list.");
            }
            var secretValue = RawGenerate(message);
            VProgram_API.AssumeValidSecret(secretValue, message, readers);
            return new PayloadSecret<TMessage>
            {
                theParams = message,
                secretValue = secretValue,
                knownReaders = readers
            };
        }

        // To prevent a secret value from being leaked by passing it to a
        // PayloadSecretGenerator for the wrong secret format, which thinks the
        // secret part is a public part and extracts it, these methods are
        // restricted to be called only via a MessageStructure on import.  TBD
        // what to do if this doesn't end up meeting our needs.

        internal void ExtractUnverified(PayloadSecret<TMessage> secret)
        {
            secret.theParams = RawExtractUnverified(secret.secretValue);
            VProgram_API.Assert(secret.theParams != null);
        }

        internal void VerifyAndExtract(PayloadSecret<TMessage> secret)
        {
            secret.theParams = RawVerifyAndExtract(secret.secretValue);
            // This currently can't be called from SVX methods, so we don't
            // actually have to do the vProgram-specific stuff.
            //// Maybe non-nullness of the root message is as much as we can say in general?
            //VProgram_API.Assert(secret.theParams != null);
            //VProgram_API.Assert(secret.secretValue != null);
            //VProgram_API.AssumeValidSecret(secret.secretValue, GetReaders(secret.theParams));
            // Verification succeeded, so we should be able to activate the SymT.
            SVX_Ops.TransferNested(secret.theParams, Signer);
        }
    }
}
